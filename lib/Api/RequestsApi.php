<?php
/**
 * RequestsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Arta\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Arta Public API
 *
 * The Arta Public API provides quote generation, transport booking, and tracking capabilities. Additionally the API enables Arta partner organizations to configure email and webhook notifications for their accounts.
 *
 * The version of the OpenAPI document: 2021-01-01
 * Contact: hello@arta.io
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.1.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Arta\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Arta\Client\ApiException;
use Arta\Client\Configuration;
use Arta\Client\HeaderSelector;
use Arta\Client\ObjectSerializer;

/**
 * RequestsApi Class Doc Comment
 *
 * @category Class
 * @package  Arta\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class RequestsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'requestsCancel' => [
            'application/json',
        ],
        'requestsCreate' => [
            'application/json',
        ],
        'requestsCustom' => [
            'application/json',
        ],
        'requestsGet' => [
            'application/json',
        ],
        'requestsList' => [
            'application/json',
        ],
        'requestsUpdateContacts' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation requestsCancel
     *
     * Cancel a Quote Request
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsCancel'] to see the possible values for this operation
     *
     * @throws \Arta\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Arta\Client\Model\Request|\Arta\Client\Model\BasicError
     */
    public function requestsCancel($authorization, $request_id, string $contentType = self::contentTypes['requestsCancel'][0])
    {
        list($response) = $this->requestsCancelWithHttpInfo($authorization, $request_id, $contentType);
        return $response;
    }

    /**
     * Operation requestsCancelWithHttpInfo
     *
     * Cancel a Quote Request
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsCancel'] to see the possible values for this operation
     *
     * @throws \Arta\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Arta\Client\Model\Request|\Arta\Client\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function requestsCancelWithHttpInfo($authorization, $request_id, string $contentType = self::contentTypes['requestsCancel'][0])
    {
        $request = $this->requestsCancelRequest($authorization, $request_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Arta\Client\Model\Request' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Arta\Client\Model\Request' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Arta\Client\Model\Request', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Arta\Client\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Arta\Client\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Arta\Client\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Arta\Client\Model\Request';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Arta\Client\Model\Request',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Arta\Client\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation requestsCancelAsync
     *
     * Cancel a Quote Request
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsCancel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestsCancelAsync($authorization, $request_id, string $contentType = self::contentTypes['requestsCancel'][0])
    {
        return $this->requestsCancelAsyncWithHttpInfo($authorization, $request_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation requestsCancelAsyncWithHttpInfo
     *
     * Cancel a Quote Request
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsCancel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestsCancelAsyncWithHttpInfo($authorization, $request_id, string $contentType = self::contentTypes['requestsCancel'][0])
    {
        $returnType = '\Arta\Client\Model\Request';
        $request = $this->requestsCancelRequest($authorization, $request_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'requestsCancel'
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsCancel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function requestsCancelRequest($authorization, $request_id, string $contentType = self::contentTypes['requestsCancel'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling requestsCancel'
            );
        }

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling requestsCancel'
            );
        }


        $resourcePath = '/requests/{request_id}/cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'request_id' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation requestsCreate
     *
     * Create a Quote Request
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  int $arta_quote_timeout Optionally set a timeout boundary in milliseconds for creating quote requests.  While Arta takes great care to return quotes quickly, several external services consumed during the process of creating quotes have varying response times. The &#x60;Arta-Quote-Timeout&#x60; header is particularly useful if your integration requires requests to return within a given time frame. When the timeout is reached, the Arta API will stop any tasks in progress and return the quotes that have already been completed. If building quotes for a particular quote type is incomplete at timeout, the API will return a disqualification message for that quote type with a &#x60;client_timeout_reached&#x60; &#x60;reason_code&#x60;. (optional)
     * @param  \Arta\Client\Model\RequestsCreateRequest $requests_create_request requests_create_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsCreate'] to see the possible values for this operation
     *
     * @throws \Arta\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Arta\Client\Model\Request|\Arta\Client\Model\BasicError
     */
    public function requestsCreate($authorization, $arta_quote_timeout = null, $requests_create_request = null, string $contentType = self::contentTypes['requestsCreate'][0])
    {
        list($response) = $this->requestsCreateWithHttpInfo($authorization, $arta_quote_timeout, $requests_create_request, $contentType);
        return $response;
    }

    /**
     * Operation requestsCreateWithHttpInfo
     *
     * Create a Quote Request
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  int $arta_quote_timeout Optionally set a timeout boundary in milliseconds for creating quote requests.  While Arta takes great care to return quotes quickly, several external services consumed during the process of creating quotes have varying response times. The &#x60;Arta-Quote-Timeout&#x60; header is particularly useful if your integration requires requests to return within a given time frame. When the timeout is reached, the Arta API will stop any tasks in progress and return the quotes that have already been completed. If building quotes for a particular quote type is incomplete at timeout, the API will return a disqualification message for that quote type with a &#x60;client_timeout_reached&#x60; &#x60;reason_code&#x60;. (optional)
     * @param  \Arta\Client\Model\RequestsCreateRequest $requests_create_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsCreate'] to see the possible values for this operation
     *
     * @throws \Arta\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Arta\Client\Model\Request|\Arta\Client\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function requestsCreateWithHttpInfo($authorization, $arta_quote_timeout = null, $requests_create_request = null, string $contentType = self::contentTypes['requestsCreate'][0])
    {
        $request = $this->requestsCreateRequest($authorization, $arta_quote_timeout, $requests_create_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\Arta\Client\Model\Request' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Arta\Client\Model\Request' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Arta\Client\Model\Request', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Arta\Client\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Arta\Client\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Arta\Client\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Arta\Client\Model\Request';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Arta\Client\Model\Request',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Arta\Client\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation requestsCreateAsync
     *
     * Create a Quote Request
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  int $arta_quote_timeout Optionally set a timeout boundary in milliseconds for creating quote requests.  While Arta takes great care to return quotes quickly, several external services consumed during the process of creating quotes have varying response times. The &#x60;Arta-Quote-Timeout&#x60; header is particularly useful if your integration requires requests to return within a given time frame. When the timeout is reached, the Arta API will stop any tasks in progress and return the quotes that have already been completed. If building quotes for a particular quote type is incomplete at timeout, the API will return a disqualification message for that quote type with a &#x60;client_timeout_reached&#x60; &#x60;reason_code&#x60;. (optional)
     * @param  \Arta\Client\Model\RequestsCreateRequest $requests_create_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestsCreateAsync($authorization, $arta_quote_timeout = null, $requests_create_request = null, string $contentType = self::contentTypes['requestsCreate'][0])
    {
        return $this->requestsCreateAsyncWithHttpInfo($authorization, $arta_quote_timeout, $requests_create_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation requestsCreateAsyncWithHttpInfo
     *
     * Create a Quote Request
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  int $arta_quote_timeout Optionally set a timeout boundary in milliseconds for creating quote requests.  While Arta takes great care to return quotes quickly, several external services consumed during the process of creating quotes have varying response times. The &#x60;Arta-Quote-Timeout&#x60; header is particularly useful if your integration requires requests to return within a given time frame. When the timeout is reached, the Arta API will stop any tasks in progress and return the quotes that have already been completed. If building quotes for a particular quote type is incomplete at timeout, the API will return a disqualification message for that quote type with a &#x60;client_timeout_reached&#x60; &#x60;reason_code&#x60;. (optional)
     * @param  \Arta\Client\Model\RequestsCreateRequest $requests_create_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestsCreateAsyncWithHttpInfo($authorization, $arta_quote_timeout = null, $requests_create_request = null, string $contentType = self::contentTypes['requestsCreate'][0])
    {
        $returnType = '\Arta\Client\Model\Request';
        $request = $this->requestsCreateRequest($authorization, $arta_quote_timeout, $requests_create_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'requestsCreate'
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  int $arta_quote_timeout Optionally set a timeout boundary in milliseconds for creating quote requests.  While Arta takes great care to return quotes quickly, several external services consumed during the process of creating quotes have varying response times. The &#x60;Arta-Quote-Timeout&#x60; header is particularly useful if your integration requires requests to return within a given time frame. When the timeout is reached, the Arta API will stop any tasks in progress and return the quotes that have already been completed. If building quotes for a particular quote type is incomplete at timeout, the API will return a disqualification message for that quote type with a &#x60;client_timeout_reached&#x60; &#x60;reason_code&#x60;. (optional)
     * @param  \Arta\Client\Model\RequestsCreateRequest $requests_create_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function requestsCreateRequest($authorization, $arta_quote_timeout = null, $requests_create_request = null, string $contentType = self::contentTypes['requestsCreate'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling requestsCreate'
            );
        }




        $resourcePath = '/requests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($arta_quote_timeout !== null) {
            $headerParams['Arta-Quote-Timeout'] = ObjectSerializer::toHeaderValue($arta_quote_timeout);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($requests_create_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($requests_create_request));
            } else {
                $httpBody = $requests_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation requestsCustom
     *
     * Request custom quotes
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  \Arta\Client\Model\RequestsCustomRequest $requests_custom_request requests_custom_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsCustom'] to see the possible values for this operation
     *
     * @throws \Arta\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Arta\Client\Model\Request|\Arta\Client\Model\BasicError
     */
    public function requestsCustom($authorization, $request_id, $requests_custom_request = null, string $contentType = self::contentTypes['requestsCustom'][0])
    {
        list($response) = $this->requestsCustomWithHttpInfo($authorization, $request_id, $requests_custom_request, $contentType);
        return $response;
    }

    /**
     * Operation requestsCustomWithHttpInfo
     *
     * Request custom quotes
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  \Arta\Client\Model\RequestsCustomRequest $requests_custom_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsCustom'] to see the possible values for this operation
     *
     * @throws \Arta\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Arta\Client\Model\Request|\Arta\Client\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function requestsCustomWithHttpInfo($authorization, $request_id, $requests_custom_request = null, string $contentType = self::contentTypes['requestsCustom'][0])
    {
        $request = $this->requestsCustomRequest($authorization, $request_id, $requests_custom_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Arta\Client\Model\Request' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Arta\Client\Model\Request' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Arta\Client\Model\Request', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Arta\Client\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Arta\Client\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Arta\Client\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Arta\Client\Model\Request';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Arta\Client\Model\Request',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Arta\Client\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation requestsCustomAsync
     *
     * Request custom quotes
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  \Arta\Client\Model\RequestsCustomRequest $requests_custom_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsCustom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestsCustomAsync($authorization, $request_id, $requests_custom_request = null, string $contentType = self::contentTypes['requestsCustom'][0])
    {
        return $this->requestsCustomAsyncWithHttpInfo($authorization, $request_id, $requests_custom_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation requestsCustomAsyncWithHttpInfo
     *
     * Request custom quotes
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  \Arta\Client\Model\RequestsCustomRequest $requests_custom_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsCustom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestsCustomAsyncWithHttpInfo($authorization, $request_id, $requests_custom_request = null, string $contentType = self::contentTypes['requestsCustom'][0])
    {
        $returnType = '\Arta\Client\Model\Request';
        $request = $this->requestsCustomRequest($authorization, $request_id, $requests_custom_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'requestsCustom'
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  \Arta\Client\Model\RequestsCustomRequest $requests_custom_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsCustom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function requestsCustomRequest($authorization, $request_id, $requests_custom_request = null, string $contentType = self::contentTypes['requestsCustom'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling requestsCustom'
            );
        }

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling requestsCustom'
            );
        }



        $resourcePath = '/requests/{request_id}/custom';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'request_id' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($requests_custom_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($requests_custom_request));
            } else {
                $httpBody = $requests_custom_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation requestsGet
     *
     * Get a Quote Request
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsGet'] to see the possible values for this operation
     *
     * @throws \Arta\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Arta\Client\Model\Request|\Arta\Client\Model\BasicError
     */
    public function requestsGet($authorization, $request_id, string $contentType = self::contentTypes['requestsGet'][0])
    {
        list($response) = $this->requestsGetWithHttpInfo($authorization, $request_id, $contentType);
        return $response;
    }

    /**
     * Operation requestsGetWithHttpInfo
     *
     * Get a Quote Request
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsGet'] to see the possible values for this operation
     *
     * @throws \Arta\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Arta\Client\Model\Request|\Arta\Client\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function requestsGetWithHttpInfo($authorization, $request_id, string $contentType = self::contentTypes['requestsGet'][0])
    {
        $request = $this->requestsGetRequest($authorization, $request_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Arta\Client\Model\Request' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Arta\Client\Model\Request' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Arta\Client\Model\Request', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Arta\Client\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Arta\Client\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Arta\Client\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Arta\Client\Model\Request';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Arta\Client\Model\Request',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Arta\Client\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation requestsGetAsync
     *
     * Get a Quote Request
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestsGetAsync($authorization, $request_id, string $contentType = self::contentTypes['requestsGet'][0])
    {
        return $this->requestsGetAsyncWithHttpInfo($authorization, $request_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation requestsGetAsyncWithHttpInfo
     *
     * Get a Quote Request
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestsGetAsyncWithHttpInfo($authorization, $request_id, string $contentType = self::contentTypes['requestsGet'][0])
    {
        $returnType = '\Arta\Client\Model\Request';
        $request = $this->requestsGetRequest($authorization, $request_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'requestsGet'
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function requestsGetRequest($authorization, $request_id, string $contentType = self::contentTypes['requestsGet'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling requestsGet'
            );
        }

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling requestsGet'
            );
        }


        $resourcePath = '/requests/{request_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'request_id' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation requestsList
     *
     * List Request records
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  int $page_size Results per page (max 50) (optional, default to 20)
     * @param  int $page Page number of the results to fetch. (optional, default to 1)
     * @param  string $search An optional structured search query (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsList'] to see the possible values for this operation
     *
     * @throws \Arta\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Arta\Client\Model\RequestList
     */
    public function requestsList($authorization, $page_size = 20, $page = 1, $search = null, string $contentType = self::contentTypes['requestsList'][0])
    {
        list($response) = $this->requestsListWithHttpInfo($authorization, $page_size, $page, $search, $contentType);
        return $response;
    }

    /**
     * Operation requestsListWithHttpInfo
     *
     * List Request records
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  int $page_size Results per page (max 50) (optional, default to 20)
     * @param  int $page Page number of the results to fetch. (optional, default to 1)
     * @param  string $search An optional structured search query (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsList'] to see the possible values for this operation
     *
     * @throws \Arta\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Arta\Client\Model\RequestList, HTTP status code, HTTP response headers (array of strings)
     */
    public function requestsListWithHttpInfo($authorization, $page_size = 20, $page = 1, $search = null, string $contentType = self::contentTypes['requestsList'][0])
    {
        $request = $this->requestsListRequest($authorization, $page_size, $page, $search, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Arta\Client\Model\RequestList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Arta\Client\Model\RequestList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Arta\Client\Model\RequestList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Arta\Client\Model\RequestList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Arta\Client\Model\RequestList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation requestsListAsync
     *
     * List Request records
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  int $page_size Results per page (max 50) (optional, default to 20)
     * @param  int $page Page number of the results to fetch. (optional, default to 1)
     * @param  string $search An optional structured search query (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestsListAsync($authorization, $page_size = 20, $page = 1, $search = null, string $contentType = self::contentTypes['requestsList'][0])
    {
        return $this->requestsListAsyncWithHttpInfo($authorization, $page_size, $page, $search, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation requestsListAsyncWithHttpInfo
     *
     * List Request records
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  int $page_size Results per page (max 50) (optional, default to 20)
     * @param  int $page Page number of the results to fetch. (optional, default to 1)
     * @param  string $search An optional structured search query (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestsListAsyncWithHttpInfo($authorization, $page_size = 20, $page = 1, $search = null, string $contentType = self::contentTypes['requestsList'][0])
    {
        $returnType = '\Arta\Client\Model\RequestList';
        $request = $this->requestsListRequest($authorization, $page_size, $page, $search, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'requestsList'
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  int $page_size Results per page (max 50) (optional, default to 20)
     * @param  int $page Page number of the results to fetch. (optional, default to 1)
     * @param  string $search An optional structured search query (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function requestsListRequest($authorization, $page_size = 20, $page = 1, $search = null, string $contentType = self::contentTypes['requestsList'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling requestsList'
            );
        }





        $resourcePath = '/requests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation requestsUpdateContacts
     *
     * Update the contacts for a Quote Request
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  \Arta\Client\Model\RequestsUpdateContactsRequest $requests_update_contacts_request requests_update_contacts_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsUpdateContacts'] to see the possible values for this operation
     *
     * @throws \Arta\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Arta\Client\Model\Request|\Arta\Client\Model\BasicError
     */
    public function requestsUpdateContacts($authorization, $request_id, $requests_update_contacts_request = null, string $contentType = self::contentTypes['requestsUpdateContacts'][0])
    {
        list($response) = $this->requestsUpdateContactsWithHttpInfo($authorization, $request_id, $requests_update_contacts_request, $contentType);
        return $response;
    }

    /**
     * Operation requestsUpdateContactsWithHttpInfo
     *
     * Update the contacts for a Quote Request
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  \Arta\Client\Model\RequestsUpdateContactsRequest $requests_update_contacts_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsUpdateContacts'] to see the possible values for this operation
     *
     * @throws \Arta\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Arta\Client\Model\Request|\Arta\Client\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function requestsUpdateContactsWithHttpInfo($authorization, $request_id, $requests_update_contacts_request = null, string $contentType = self::contentTypes['requestsUpdateContacts'][0])
    {
        $request = $this->requestsUpdateContactsRequest($authorization, $request_id, $requests_update_contacts_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Arta\Client\Model\Request' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Arta\Client\Model\Request' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Arta\Client\Model\Request', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Arta\Client\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Arta\Client\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Arta\Client\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Arta\Client\Model\Request';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Arta\Client\Model\Request',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Arta\Client\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation requestsUpdateContactsAsync
     *
     * Update the contacts for a Quote Request
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  \Arta\Client\Model\RequestsUpdateContactsRequest $requests_update_contacts_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsUpdateContacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestsUpdateContactsAsync($authorization, $request_id, $requests_update_contacts_request = null, string $contentType = self::contentTypes['requestsUpdateContacts'][0])
    {
        return $this->requestsUpdateContactsAsyncWithHttpInfo($authorization, $request_id, $requests_update_contacts_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation requestsUpdateContactsAsyncWithHttpInfo
     *
     * Update the contacts for a Quote Request
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  \Arta\Client\Model\RequestsUpdateContactsRequest $requests_update_contacts_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsUpdateContacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestsUpdateContactsAsyncWithHttpInfo($authorization, $request_id, $requests_update_contacts_request = null, string $contentType = self::contentTypes['requestsUpdateContacts'][0])
    {
        $returnType = '\Arta\Client\Model\Request';
        $request = $this->requestsUpdateContactsRequest($authorization, $request_id, $requests_update_contacts_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'requestsUpdateContacts'
     *
     * @param  string $authorization Authorize your API calls with an Arta API token (required)
     * @param  string $request_id request_id parameter (required)
     * @param  \Arta\Client\Model\RequestsUpdateContactsRequest $requests_update_contacts_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestsUpdateContacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function requestsUpdateContactsRequest($authorization, $request_id, $requests_update_contacts_request = null, string $contentType = self::contentTypes['requestsUpdateContacts'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling requestsUpdateContacts'
            );
        }

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling requestsUpdateContacts'
            );
        }



        $resourcePath = '/requests/{request_id}/contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'request_id' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($requests_update_contacts_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($requests_update_contacts_request));
            } else {
                $httpBody = $requests_update_contacts_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
