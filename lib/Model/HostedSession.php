<?php
/**
 * HostedSession
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Arta Public API
 *
 * The Arta Public API provides quote generation, transport booking, and tracking capabilities. Additionally the API enables Arta partner organizations to configure email and webhook notifications for their accounts.
 *
 * The version of the OpenAPI document: 2021-01-01
 * Contact: hello@arta.io
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.1.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * HostedSession Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class HostedSession implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'hostedSession';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'additional_services' => 'string[]',
        'cancel_url' => 'string',
        'created_at' => 'string',
        'destination' => '\OpenAPI\Client\Model\NullableLocation',
        'id' => 'int',
        'insurance' => 'string',
        'internal_reference' => 'string',
        'origin' => '\OpenAPI\Client\Model\Location',
        'payment_process' => 'string',
        'private_token' => 'string',
        'public_reference' => 'string',
        'shipping_notes' => 'string',
        'shortcode' => 'string',
        'status' => 'string',
        'success_url' => 'string',
        'updated_at' => 'string',
        'url' => 'string',
        'preferred_quote_types' => 'string[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'additional_services' => null,
        'cancel_url' => null,
        'created_at' => null,
        'destination' => null,
        'id' => 'int64',
        'insurance' => null,
        'internal_reference' => null,
        'origin' => null,
        'payment_process' => null,
        'private_token' => null,
        'public_reference' => null,
        'shipping_notes' => null,
        'shortcode' => null,
        'status' => null,
        'success_url' => null,
        'updated_at' => null,
        'url' => null,
        'preferred_quote_types' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'additional_services' => false,
		'cancel_url' => false,
		'created_at' => false,
		'destination' => true,
		'id' => false,
		'insurance' => true,
		'internal_reference' => true,
		'origin' => false,
		'payment_process' => false,
		'private_token' => false,
		'public_reference' => true,
		'shipping_notes' => true,
		'shortcode' => false,
		'status' => false,
		'success_url' => false,
		'updated_at' => false,
		'url' => true,
		'preferred_quote_types' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'additional_services' => 'additional_services',
        'cancel_url' => 'cancel_url',
        'created_at' => 'created_at',
        'destination' => 'destination',
        'id' => 'id',
        'insurance' => 'insurance',
        'internal_reference' => 'internal_reference',
        'origin' => 'origin',
        'payment_process' => 'payment_process',
        'private_token' => 'private_token',
        'public_reference' => 'public_reference',
        'shipping_notes' => 'shipping_notes',
        'shortcode' => 'shortcode',
        'status' => 'status',
        'success_url' => 'success_url',
        'updated_at' => 'updated_at',
        'url' => 'url',
        'preferred_quote_types' => 'preferred_quote_types'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'additional_services' => 'setAdditionalServices',
        'cancel_url' => 'setCancelUrl',
        'created_at' => 'setCreatedAt',
        'destination' => 'setDestination',
        'id' => 'setId',
        'insurance' => 'setInsurance',
        'internal_reference' => 'setInternalReference',
        'origin' => 'setOrigin',
        'payment_process' => 'setPaymentProcess',
        'private_token' => 'setPrivateToken',
        'public_reference' => 'setPublicReference',
        'shipping_notes' => 'setShippingNotes',
        'shortcode' => 'setShortcode',
        'status' => 'setStatus',
        'success_url' => 'setSuccessUrl',
        'updated_at' => 'setUpdatedAt',
        'url' => 'setUrl',
        'preferred_quote_types' => 'setPreferredQuoteTypes'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'additional_services' => 'getAdditionalServices',
        'cancel_url' => 'getCancelUrl',
        'created_at' => 'getCreatedAt',
        'destination' => 'getDestination',
        'id' => 'getId',
        'insurance' => 'getInsurance',
        'internal_reference' => 'getInternalReference',
        'origin' => 'getOrigin',
        'payment_process' => 'getPaymentProcess',
        'private_token' => 'getPrivateToken',
        'public_reference' => 'getPublicReference',
        'shipping_notes' => 'getShippingNotes',
        'shortcode' => 'getShortcode',
        'status' => 'getStatus',
        'success_url' => 'getSuccessUrl',
        'updated_at' => 'getUpdatedAt',
        'url' => 'getUrl',
        'preferred_quote_types' => 'getPreferredQuoteTypes'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const PAYMENT_PROCESS_CHECKOUT = 'checkout';
    public const PAYMENT_PROCESS_INVOICING = 'invoicing';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPaymentProcessAllowableValues()
    {
        return [
            self::PAYMENT_PROCESS_CHECKOUT,
            self::PAYMENT_PROCESS_INVOICING,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('additional_services', $data ?? [], null);
        $this->setIfExists('cancel_url', $data ?? [], null);
        $this->setIfExists('created_at', $data ?? [], null);
        $this->setIfExists('destination', $data ?? [], null);
        $this->setIfExists('id', $data ?? [], null);
        $this->setIfExists('insurance', $data ?? [], null);
        $this->setIfExists('internal_reference', $data ?? [], null);
        $this->setIfExists('origin', $data ?? [], null);
        $this->setIfExists('payment_process', $data ?? [], null);
        $this->setIfExists('private_token', $data ?? [], null);
        $this->setIfExists('public_reference', $data ?? [], null);
        $this->setIfExists('shipping_notes', $data ?? [], null);
        $this->setIfExists('shortcode', $data ?? [], null);
        $this->setIfExists('status', $data ?? [], null);
        $this->setIfExists('success_url', $data ?? [], null);
        $this->setIfExists('updated_at', $data ?? [], null);
        $this->setIfExists('url', $data ?? [], null);
        $this->setIfExists('preferred_quote_types', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if (!is_null($this->container['internal_reference']) && (mb_strlen($this->container['internal_reference']) > 255)) {
            $invalidProperties[] = "invalid value for 'internal_reference', the character length must be smaller than or equal to 255.";
        }

        $allowedValues = $this->getPaymentProcessAllowableValues();
        if (!is_null($this->container['payment_process']) && !in_array($this->container['payment_process'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'payment_process', must be one of '%s'",
                $this->container['payment_process'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['public_reference']) && (mb_strlen($this->container['public_reference']) > 255)) {
            $invalidProperties[] = "invalid value for 'public_reference', the character length must be smaller than or equal to 255.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets additional_services
     *
     * @return string[]|null
     */
    public function getAdditionalServices()
    {
        return $this->container['additional_services'];
    }

    /**
     * Sets additional_services
     *
     * @param string[]|null $additional_services Any desired services, such as unpacking, installation, etc. can be sent through in the request and will be treated as if that requested service is required. Requested services may disqualify certain segments of shipping services offered by Arta depending on location and object details.
     *
     * @return self
     */
    public function setAdditionalServices($additional_services)
    {
        if (is_null($additional_services)) {
            throw new \InvalidArgumentException('non-nullable additional_services cannot be null');
        }
        $this->container['additional_services'] = $additional_services;

        return $this;
    }

    /**
     * Gets cancel_url
     *
     * @return string|null
     */
    public function getCancelUrl()
    {
        return $this->container['cancel_url'];
    }

    /**
     * Sets cancel_url
     *
     * @param string|null $cancel_url The URL the user will be redirected to after a Arta Booking session is cancelled
     *
     * @return self
     */
    public function setCancelUrl($cancel_url)
    {
        if (is_null($cancel_url)) {
            throw new \InvalidArgumentException('non-nullable cancel_url cannot be null');
        }
        $this->container['cancel_url'] = $cancel_url;

        return $this;
    }

    /**
     * Gets created_at
     *
     * @return string|null
     */
    public function getCreatedAt()
    {
        return $this->container['created_at'];
    }

    /**
     * Sets created_at
     *
     * @param string|null $created_at created_at
     *
     * @return self
     */
    public function setCreatedAt($created_at)
    {
        if (is_null($created_at)) {
            throw new \InvalidArgumentException('non-nullable created_at cannot be null');
        }
        $this->container['created_at'] = $created_at;

        return $this;
    }

    /**
     * Gets destination
     *
     * @return \OpenAPI\Client\Model\NullableLocation|null
     */
    public function getDestination()
    {
        return $this->container['destination'];
    }

    /**
     * Sets destination
     *
     * @param \OpenAPI\Client\Model\NullableLocation|null $destination destination
     *
     * @return self
     */
    public function setDestination($destination)
    {
        if (is_null($destination)) {
            array_push($this->openAPINullablesSetToNull, 'destination');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('destination', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['destination'] = $destination;

        return $this;
    }

    /**
     * Gets id
     *
     * @return int|null
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param int|null $id id
     *
     * @return self
     */
    public function setId($id)
    {
        if (is_null($id)) {
            throw new \InvalidArgumentException('non-nullable id cannot be null');
        }
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets insurance
     *
     * @return string|null
     */
    public function getInsurance()
    {
        return $this->container['insurance'];
    }

    /**
     * Sets insurance
     *
     * @param string|null $insurance The id of an insurance type. If requesting Arta insurance, object values must be provided.
     *
     * @return self
     */
    public function setInsurance($insurance)
    {
        if (is_null($insurance)) {
            array_push($this->openAPINullablesSetToNull, 'insurance');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('insurance', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['insurance'] = $insurance;

        return $this;
    }

    /**
     * Gets internal_reference
     *
     * @return string|null
     */
    public function getInternalReference()
    {
        return $this->container['internal_reference'];
    }

    /**
     * Sets internal_reference
     *
     * @param string|null $internal_reference This field can be used to pass through any data about the request you may want returned unaltered for your own later usage
     *
     * @return self
     */
    public function setInternalReference($internal_reference)
    {
        if (is_null($internal_reference)) {
            array_push($this->openAPINullablesSetToNull, 'internal_reference');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('internal_reference', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        if (!is_null($internal_reference) && (mb_strlen($internal_reference) > 255)) {
            throw new \InvalidArgumentException('invalid length for $internal_reference when calling HostedSession., must be smaller than or equal to 255.');
        }

        $this->container['internal_reference'] = $internal_reference;

        return $this;
    }

    /**
     * Gets origin
     *
     * @return \OpenAPI\Client\Model\Location|null
     */
    public function getOrigin()
    {
        return $this->container['origin'];
    }

    /**
     * Sets origin
     *
     * @param \OpenAPI\Client\Model\Location|null $origin origin
     *
     * @return self
     */
    public function setOrigin($origin)
    {
        if (is_null($origin)) {
            throw new \InvalidArgumentException('non-nullable origin cannot be null');
        }
        $this->container['origin'] = $origin;

        return $this;
    }

    /**
     * Gets payment_process
     *
     * @return string|null
     */
    public function getPaymentProcess()
    {
        return $this->container['payment_process'];
    }

    /**
     * Sets payment_process
     *
     * @param string|null $payment_process The primary method by which payment to Arta will be handled for any shipment booked through this hosted session
     *
     * @return self
     */
    public function setPaymentProcess($payment_process)
    {
        if (is_null($payment_process)) {
            throw new \InvalidArgumentException('non-nullable payment_process cannot be null');
        }
        $allowedValues = $this->getPaymentProcessAllowableValues();
        if (!in_array($payment_process, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'payment_process', must be one of '%s'",
                    $payment_process,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['payment_process'] = $payment_process;

        return $this;
    }

    /**
     * Gets private_token
     *
     * @return string|null
     */
    public function getPrivateToken()
    {
        return $this->container['private_token'];
    }

    /**
     * Sets private_token
     *
     * @param string|null $private_token A private access token for this resource. It used to generate the private URL for the hosted session
     *
     * @return self
     */
    public function setPrivateToken($private_token)
    {
        if (is_null($private_token)) {
            throw new \InvalidArgumentException('non-nullable private_token cannot be null');
        }
        $this->container['private_token'] = $private_token;

        return $this;
    }

    /**
     * Gets public_reference
     *
     * @return string|null
     */
    public function getPublicReference()
    {
        return $this->container['public_reference'];
    }

    /**
     * Sets public_reference
     *
     * @param string|null $public_reference A client defined name for the resource. The value provided for the public_reference field may appear in notification emails and public web pages
     *
     * @return self
     */
    public function setPublicReference($public_reference)
    {
        if (is_null($public_reference)) {
            array_push($this->openAPINullablesSetToNull, 'public_reference');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('public_reference', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        if (!is_null($public_reference) && (mb_strlen($public_reference) > 255)) {
            throw new \InvalidArgumentException('invalid length for $public_reference when calling HostedSession., must be smaller than or equal to 255.');
        }

        $this->container['public_reference'] = $public_reference;

        return $this;
    }

    /**
     * Gets shipping_notes
     *
     * @return string|null
     */
    public function getShippingNotes()
    {
        return $this->container['shipping_notes'];
    }

    /**
     * Sets shipping_notes
     *
     * @param string|null $shipping_notes This field can be used to pass through any notes to Arta that a customer might want to provide about the request
     *
     * @return self
     */
    public function setShippingNotes($shipping_notes)
    {
        if (is_null($shipping_notes)) {
            array_push($this->openAPINullablesSetToNull, 'shipping_notes');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('shipping_notes', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['shipping_notes'] = $shipping_notes;

        return $this;
    }

    /**
     * Gets shortcode
     *
     * @return string|null
     */
    public function getShortcode()
    {
        return $this->container['shortcode'];
    }

    /**
     * Sets shortcode
     *
     * @param string|null $shortcode A brief and unique string identifier for the request resource
     *
     * @return self
     */
    public function setShortcode($shortcode)
    {
        if (is_null($shortcode)) {
            throw new \InvalidArgumentException('non-nullable shortcode cannot be null');
        }
        $this->container['shortcode'] = $shortcode;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string|null
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string|null $status status
     *
     * @return self
     */
    public function setStatus($status)
    {
        if (is_null($status)) {
            throw new \InvalidArgumentException('non-nullable status cannot be null');
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets success_url
     *
     * @return string|null
     */
    public function getSuccessUrl()
    {
        return $this->container['success_url'];
    }

    /**
     * Sets success_url
     *
     * @param string|null $success_url The URL the user will be redirected to after a Arta Booking session is completed
     *
     * @return self
     */
    public function setSuccessUrl($success_url)
    {
        if (is_null($success_url)) {
            throw new \InvalidArgumentException('non-nullable success_url cannot be null');
        }
        $this->container['success_url'] = $success_url;

        return $this;
    }

    /**
     * Gets updated_at
     *
     * @return string|null
     */
    public function getUpdatedAt()
    {
        return $this->container['updated_at'];
    }

    /**
     * Sets updated_at
     *
     * @param string|null $updated_at updated_at
     *
     * @return self
     */
    public function setUpdatedAt($updated_at)
    {
        if (is_null($updated_at)) {
            throw new \InvalidArgumentException('non-nullable updated_at cannot be null');
        }
        $this->container['updated_at'] = $updated_at;

        return $this;
    }

    /**
     * Gets url
     *
     * @return string|null
     */
    public function getUrl()
    {
        return $this->container['url'];
    }

    /**
     * Sets url
     *
     * @param string|null $url The Arta Booking web URL for this Hosted Session
     *
     * @return self
     */
    public function setUrl($url)
    {
        if (is_null($url)) {
            array_push($this->openAPINullablesSetToNull, 'url');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('url', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['url'] = $url;

        return $this;
    }

    /**
     * Gets preferred_quote_types
     *
     * @return string[]|null
     */
    public function getPreferredQuoteTypes()
    {
        return $this->container['preferred_quote_types'];
    }

    /**
     * Sets preferred_quote_types
     *
     * @param string[]|null $preferred_quote_types An optional field presenting the list of quote types the caller instructed Arta to return as part of the hosted session
     *
     * @return self
     */
    public function setPreferredQuoteTypes($preferred_quote_types)
    {
        if (is_null($preferred_quote_types)) {
            throw new \InvalidArgumentException('non-nullable preferred_quote_types cannot be null');
        }
        $this->container['preferred_quote_types'] = $preferred_quote_types;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


