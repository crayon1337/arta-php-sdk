<?php
/**
 * RequestsCreateRequestRequest
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Arta Public API
 *
 * The Arta Public API provides quote generation, transport booking, and tracking capabilities. Additionally the API enables Arta partner organizations to configure email and webhook notifications for their accounts.
 *
 * The version of the OpenAPI document: 2021-01-01
 * Contact: hello@arta.io
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.1.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * RequestsCreateRequestRequest Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class RequestsCreateRequestRequest implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'requests_create_request_request';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'additional_services' => 'string[]',
        'currency' => 'string',
        'destination' => '\OpenAPI\Client\Model\RequestsCreateRequestRequestDestination',
        'insurance' => 'string',
        'internal_reference' => 'string',
        'objects' => '\OpenAPI\Client\Model\RequestsCreateRequestRequestObjectsInner[]',
        'origin' => '\OpenAPI\Client\Model\RequestsCreateRequestRequestOrigin',
        'preferred_quote_types' => 'string[]',
        'public_reference' => 'string',
        'shipping_notes' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'additional_services' => null,
        'currency' => null,
        'destination' => null,
        'insurance' => null,
        'internal_reference' => null,
        'objects' => null,
        'origin' => null,
        'preferred_quote_types' => null,
        'public_reference' => null,
        'shipping_notes' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'additional_services' => false,
		'currency' => false,
		'destination' => false,
		'insurance' => false,
		'internal_reference' => false,
		'objects' => false,
		'origin' => false,
		'preferred_quote_types' => false,
		'public_reference' => false,
		'shipping_notes' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'additional_services' => 'additional_services',
        'currency' => 'currency',
        'destination' => 'destination',
        'insurance' => 'insurance',
        'internal_reference' => 'internal_reference',
        'objects' => 'objects',
        'origin' => 'origin',
        'preferred_quote_types' => 'preferred_quote_types',
        'public_reference' => 'public_reference',
        'shipping_notes' => 'shipping_notes'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'additional_services' => 'setAdditionalServices',
        'currency' => 'setCurrency',
        'destination' => 'setDestination',
        'insurance' => 'setInsurance',
        'internal_reference' => 'setInternalReference',
        'objects' => 'setObjects',
        'origin' => 'setOrigin',
        'preferred_quote_types' => 'setPreferredQuoteTypes',
        'public_reference' => 'setPublicReference',
        'shipping_notes' => 'setShippingNotes'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'additional_services' => 'getAdditionalServices',
        'currency' => 'getCurrency',
        'destination' => 'getDestination',
        'insurance' => 'getInsurance',
        'internal_reference' => 'getInternalReference',
        'objects' => 'getObjects',
        'origin' => 'getOrigin',
        'preferred_quote_types' => 'getPreferredQuoteTypes',
        'public_reference' => 'getPublicReference',
        'shipping_notes' => 'getShippingNotes'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('additional_services', $data ?? [], null);
        $this->setIfExists('currency', $data ?? [], 'USD');
        $this->setIfExists('destination', $data ?? [], null);
        $this->setIfExists('insurance', $data ?? [], null);
        $this->setIfExists('internal_reference', $data ?? [], null);
        $this->setIfExists('objects', $data ?? [], null);
        $this->setIfExists('origin', $data ?? [], null);
        $this->setIfExists('preferred_quote_types', $data ?? [], null);
        $this->setIfExists('public_reference', $data ?? [], null);
        $this->setIfExists('shipping_notes', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if (!is_null($this->container['currency']) && (mb_strlen($this->container['currency']) > 3)) {
            $invalidProperties[] = "invalid value for 'currency', the character length must be smaller than or equal to 3.";
        }

        if (!is_null($this->container['currency']) && (mb_strlen($this->container['currency']) < 3)) {
            $invalidProperties[] = "invalid value for 'currency', the character length must be bigger than or equal to 3.";
        }

        if (!is_null($this->container['currency']) && !preg_match("/^[A-Z]{3}$/", $this->container['currency'])) {
            $invalidProperties[] = "invalid value for 'currency', must be conform to the pattern /^[A-Z]{3}$/.";
        }

        if ($this->container['destination'] === null) {
            $invalidProperties[] = "'destination' can't be null";
        }
        if (!is_null($this->container['internal_reference']) && (mb_strlen($this->container['internal_reference']) > 255)) {
            $invalidProperties[] = "invalid value for 'internal_reference', the character length must be smaller than or equal to 255.";
        }

        if ($this->container['objects'] === null) {
            $invalidProperties[] = "'objects' can't be null";
        }
        if ($this->container['origin'] === null) {
            $invalidProperties[] = "'origin' can't be null";
        }
        if (!is_null($this->container['public_reference']) && (mb_strlen($this->container['public_reference']) > 255)) {
            $invalidProperties[] = "invalid value for 'public_reference', the character length must be smaller than or equal to 255.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets additional_services
     *
     * @return string[]|null
     */
    public function getAdditionalServices()
    {
        return $this->container['additional_services'];
    }

    /**
     * Sets additional_services
     *
     * @param string[]|null $additional_services Any desired services, such as unpacking, installation, etc. can be sent through in the request and will be treated as if that requested service is required, meaning this may disqualify certain segments of shipping services we offer.
     *
     * @return self
     */
    public function setAdditionalServices($additional_services)
    {
        if (is_null($additional_services)) {
            throw new \InvalidArgumentException('non-nullable additional_services cannot be null');
        }
        $this->container['additional_services'] = $additional_services;

        return $this;
    }

    /**
     * Gets currency
     *
     * @return string|null
     */
    public function getCurrency()
    {
        return $this->container['currency'];
    }

    /**
     * Sets currency
     *
     * @param string|null $currency The currency that the quote should be returned in. Formatted as ISO 4217 three-letter alphabetic currency code. Options are defined in the Currencies metadata endpoint
     *
     * @return self
     */
    public function setCurrency($currency)
    {
        if (is_null($currency)) {
            throw new \InvalidArgumentException('non-nullable currency cannot be null');
        }
        if ((mb_strlen($currency) > 3)) {
            throw new \InvalidArgumentException('invalid length for $currency when calling RequestsCreateRequestRequest., must be smaller than or equal to 3.');
        }
        if ((mb_strlen($currency) < 3)) {
            throw new \InvalidArgumentException('invalid length for $currency when calling RequestsCreateRequestRequest., must be bigger than or equal to 3.');
        }
        if ((!preg_match("/^[A-Z]{3}$/", ObjectSerializer::toString($currency)))) {
            throw new \InvalidArgumentException("invalid value for \$currency when calling RequestsCreateRequestRequest., must conform to the pattern /^[A-Z]{3}$/.");
        }

        $this->container['currency'] = $currency;

        return $this;
    }

    /**
     * Gets destination
     *
     * @return \OpenAPI\Client\Model\RequestsCreateRequestRequestDestination
     */
    public function getDestination()
    {
        return $this->container['destination'];
    }

    /**
     * Sets destination
     *
     * @param \OpenAPI\Client\Model\RequestsCreateRequestRequestDestination $destination destination
     *
     * @return self
     */
    public function setDestination($destination)
    {
        if (is_null($destination)) {
            throw new \InvalidArgumentException('non-nullable destination cannot be null');
        }
        $this->container['destination'] = $destination;

        return $this;
    }

    /**
     * Gets insurance
     *
     * @return string|null
     */
    public function getInsurance()
    {
        return $this->container['insurance'];
    }

    /**
     * Sets insurance
     *
     * @param string|null $insurance The ID of the requested Arta insurance type. Options are defined in the Insurances metadata endpoint
     *
     * @return self
     */
    public function setInsurance($insurance)
    {
        if (is_null($insurance)) {
            throw new \InvalidArgumentException('non-nullable insurance cannot be null');
        }
        $this->container['insurance'] = $insurance;

        return $this;
    }

    /**
     * Gets internal_reference
     *
     * @return string|null
     */
    public function getInternalReference()
    {
        return $this->container['internal_reference'];
    }

    /**
     * Sets internal_reference
     *
     * @param string|null $internal_reference This field can be used to pass through any data that you may want returned unaltered for your own later usage
     *
     * @return self
     */
    public function setInternalReference($internal_reference)
    {
        if (is_null($internal_reference)) {
            throw new \InvalidArgumentException('non-nullable internal_reference cannot be null');
        }
        if ((mb_strlen($internal_reference) > 255)) {
            throw new \InvalidArgumentException('invalid length for $internal_reference when calling RequestsCreateRequestRequest., must be smaller than or equal to 255.');
        }

        $this->container['internal_reference'] = $internal_reference;

        return $this;
    }

    /**
     * Gets objects
     *
     * @return \OpenAPI\Client\Model\RequestsCreateRequestRequestObjectsInner[]
     */
    public function getObjects()
    {
        return $this->container['objects'];
    }

    /**
     * Sets objects
     *
     * @param \OpenAPI\Client\Model\RequestsCreateRequestRequestObjectsInner[] $objects objects
     *
     * @return self
     */
    public function setObjects($objects)
    {
        if (is_null($objects)) {
            throw new \InvalidArgumentException('non-nullable objects cannot be null');
        }
        $this->container['objects'] = $objects;

        return $this;
    }

    /**
     * Gets origin
     *
     * @return \OpenAPI\Client\Model\RequestsCreateRequestRequestOrigin
     */
    public function getOrigin()
    {
        return $this->container['origin'];
    }

    /**
     * Sets origin
     *
     * @param \OpenAPI\Client\Model\RequestsCreateRequestRequestOrigin $origin origin
     *
     * @return self
     */
    public function setOrigin($origin)
    {
        if (is_null($origin)) {
            throw new \InvalidArgumentException('non-nullable origin cannot be null');
        }
        $this->container['origin'] = $origin;

        return $this;
    }

    /**
     * Gets preferred_quote_types
     *
     * @return string[]|null
     */
    public function getPreferredQuoteTypes()
    {
        return $this->container['preferred_quote_types'];
    }

    /**
     * Sets preferred_quote_types
     *
     * @param string[]|null $preferred_quote_types Optionally instruct the Arta API to return a subset of quote types for this request. For example if you would prefer to only return Select quotes for a particular request, you can set this field to `[\"select\"]` You can find all available quote type IDs at the /metadata/quotes endpoint.
     *
     * @return self
     */
    public function setPreferredQuoteTypes($preferred_quote_types)
    {
        if (is_null($preferred_quote_types)) {
            throw new \InvalidArgumentException('non-nullable preferred_quote_types cannot be null');
        }
        $this->container['preferred_quote_types'] = $preferred_quote_types;

        return $this;
    }

    /**
     * Gets public_reference
     *
     * @return string|null
     */
    public function getPublicReference()
    {
        return $this->container['public_reference'];
    }

    /**
     * Sets public_reference
     *
     * @param string|null $public_reference A client defined name for the request. The value provided for the public_reference field may appear in notification emails and shipment detail pages
     *
     * @return self
     */
    public function setPublicReference($public_reference)
    {
        if (is_null($public_reference)) {
            throw new \InvalidArgumentException('non-nullable public_reference cannot be null');
        }
        if ((mb_strlen($public_reference) > 255)) {
            throw new \InvalidArgumentException('invalid length for $public_reference when calling RequestsCreateRequestRequest., must be smaller than or equal to 255.');
        }

        $this->container['public_reference'] = $public_reference;

        return $this;
    }

    /**
     * Gets shipping_notes
     *
     * @return string|null
     */
    public function getShippingNotes()
    {
        return $this->container['shipping_notes'];
    }

    /**
     * Sets shipping_notes
     *
     * @param string|null $shipping_notes This field can be used to pass through any notes to Arta that a customer might want to provide about the request
     *
     * @return self
     */
    public function setShippingNotes($shipping_notes)
    {
        if (is_null($shipping_notes)) {
            throw new \InvalidArgumentException('non-nullable shipping_notes cannot be null');
        }
        $this->container['shipping_notes'] = $shipping_notes;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


